# Wrapup

## Final Exam

12/21 9am-11am
Can bring cheatsheets in size of 2 A4 paper

- Go over slides
  - to organize the cheatpapers
- Focus on the examples
  - Preferably, practise examples, quizzes, exercise on slides
- No need to memorize APIs
  - Will be provided if needed

> HW3 should be renewed

## Quick overview of STL

- vector
- deque
- std::array

How to choose:

好的，以下是 STL 容器 std::vector、std::deque 和 std::array 的选择指南：

**1. `std::vector`**

Vetcor

- **优点：**
  - 内存布局连续，随机访问速度快。
  - 尾部插入/删除效率高。
  - 大小可动态调整，适应数据增长。
- **缺点：**
  - 头部或中部插入/删除效率低。
  - 在大小发生重大变化时可能会重新分配内存。

**2. `std::deque`**

Deque

- **优点：**
  - 头部、中部和尾部插入/删除效率高。
  - 不需要连续内存，适合处理大型数据。
- **缺点：**
  - 与 std::vector 相比，随机访问速度慢。
  - 可能有略高的内存开销。

**3. `std::array`**

Array

- **优点：**
  - 大小固定，编译时已知内存占用。
  - 随机访问和元素访问效率高。
  - 无需动态内存分配，避免潜在的内存泄漏。
- **缺点：**
  - 大小固定，创建后无法调整大小。
  - 不适合动态增长的数据。

**选择合适的容器：**

- **对于随机访问和尾部插入/删除效率要求高的场合：std::vector 是最佳选择。**
- **对于头部、中部和尾部插入/删除效率要求高，且需要处理大型数据的场合：std::deque 更适合。**
- **对于固定大小的集合，具有已知内存需求和快速访问的场合：std::array 是理想选择。**

以下是总结关键点的表格：

| 特性              | std::vector       | std::deque        | std::array      |
|---------------------|--------------------|--------------------|------------------|
| 内存布局      | 连续        | 非连续     | 连续        |
| 大小                | 动态           | 动态           | 固定            |
| 随机访问     | 快              | 慢             | 快              |
| 插入/删除 | 尾部效率高 | 任何位置效率高 | 效率高         |
| 内存开销     | 较低              | 略高             | 较低              |

**其他需要考虑的因素：**

- **插入/删除频率：**如果您经常插入/删除元素，尤其是在头部或中部，则 `std::deque` 可能会更好。
- **数据大小：**如果您处理的是大型数据集，则 `std::deque` 在内存使用方面可能更有效率。
- **性能要求：**如果您的应用程序对性能至关重要，请考虑速度和内存使用之间的权衡。

请记住，最佳选择取决于您的具体需求和数据的特性。

```cpp
for (std::vector<int>::iterator it = vector0.begin(); it != vector0.end(); it++) {
    std::cout << *it << " ";
    }

for (std::list<int>::iterator it = list0.begin(); it != list0.end(); it++) {
    std::cout << *it << " ";
    }
```

```cpp
void insertValue(Container& elements, int value){
    auto it = elements.begin();
    while (it != elements.end() && *it < value) {
        ++it;
    }
    elements.insert(it, value);
}
```

## Associative containers

好的，以下是关于 C++ 关联容器的简介：

**关联容器是一种强大而通用的数据结构，可提供基于键的有效存储和检索数据。它们是使用平衡搜索树实现的，可提供有效的搜索、插入和删除操作。**

**以下是四种关联容器的概述：**

**1. set:**

- 存储唯一元素。
- 元素按键排序。
- 提供有效的搜索、插入和删除操作。
- 适用于表示需要顺序和唯一性的集合，例如唯一 ID 列表或排序的数据集。

**2. multiset:**

- 允许重复键的元素存储。
- 元素按键排序。
- 提供有效的搜索、插入和删除操作。
- 适用于表示需要顺序但允许重复的集合，例如优先级列表或可能重复元素的排序数据集。

**3. map:**

- 存储键值对。
- 键是唯一的且有序的。
- 提供基于键快速访问值的操作。
- 适用于表示需要快速访问基于键的元素的集合，例如字典、缓存或配置文件。

**4. multimap:**

- 允许重复键的键值对存储。
- 键是有序的。
- 提供基于键快速访问值的操作。
- 适用于需要快速访问具有相同键的多个元素的集合，例如索引或逆映射。

**以下表格总结了这些容器的关键区别：**

| 特征 | set | multiset | map | multimap |
|---|---|---|---|---|
| 键的唯一性 | 唯一 | 允许重复 | 唯一 | 允许重复 |
| 键的顺序 | 有序 | 有序 | 有序 | 有序 |
| 值的类型 | 单个 | 单个 | 每个键关联一个 | 每个键关联一个 |
| 用例 | 唯一元素、排序集 | 有序元素允许重复 | 键值对、快速按键访问 | 键值对允许重复键、按键访问 |

**需要考虑的其他要点：**

- 所有关联容器都使用迭代器来访问元素。
- 您可以指定自定义比较函数来确定元素的顺序。
- 您可以在 C++ 标准库参考中找到有关每个容器的更详细信息。

希望这提供了关于关联容器的良好概述。如果您有任何关于特定方面或用例示例的问题，请随时提出。
